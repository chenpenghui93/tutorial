# 基础
- Remote Dictionary Service，远程字典服务
- SQL与NoSQL
  - 关系型数据库
    - 特点
      - 表格，基于行存储数据，二维
      - 结构化数据，数据存储有固定格式(schema)，数据需要适应表结构
      - 表与表之间存在关联
      - 大都支持SQL操作，支持复杂关联
      - 通过支持事务(ACID)来提供严格或实时的数据一致性
    - 限制
      - 垂直扩容，扩大磁盘容量、堆硬件、不支持动态扩缩容；水平扩容需要复杂的技术，如分库分表
      - 表结构修改困难，因此存储格式受到限制
      - 关系型数据库通常将数据持久化到磁盘，在高并发和海量数据情况下，基于磁盘读写压力较大
  - 非关系型数据库(non-relational/Not only SQL)
    - 特点
      - 存储非结构化的数据，如文本、图片、音频、视频
      - 表之间无关联，可扩展性强
      - 保证数据的最终一致性，遵循BASE理论
        - Basically Available 基本可用
        - Soft state 软状态
        - Eventually Consistent 最终一致性
      - 支持海量数据的存储和高并发的高效读写
      - 支持分布式，能够对数据进行分片存储，扩缩容简单
    - NoSQL数据库 [https://hostingdata.co.uk/nosql-database/](https://hostingdata.co.uk/nosql-database/)
- Redis特性
  - 更丰富的数据类型
  - 支持多种编程语言
  - 功能丰富：持久化机制、内存淘汰策略、事务、发布订阅、pipline、lua
  - 支持集群、分布式
- 安装启动 
  - 服务端 [https://gper.club/articles/7e7e7f7ff3g5bgccg66](https://gper.club/articles/7e7e7f7ff3g5bgccg66)
  - 客户端工具 [https://rdm.dev/](https://rdm.dev/)
- 基本数据类型
 - String
   - 存储类型
     - INT
     - FLOAT
     - String
   - 操作命令
   - 存储结构
     - dictEntry
   - 应用场景
     - 缓存热点数据
     - 分布式数据共享 例如，利用srping-session-data-redis实现分布式Session
     - 分布式锁 例如，使用jedis；使用包含setnx和expire指令的lua脚本
     - 全局id 例如，利用int类型的原子操作incrby
     - 计数器
     - 限流
 - Hash
   - 存储类型
     - 多个无序键值对，最大存储量2^32-1（约40亿）
   - 操作命令
   - 存储结构
     - ziplist
     - hashtable
   - 应用场景
 - Set
   - 存储类型
     - String类型的无序不重复集合，最大存储量2^32-1（约40亿）
   - 操作命令
   - 存储结构
     - intset
     - hashtable
   - 应用场景
     - 抽奖
     - 点赞、签到、打卡
     - 商品标签、筛选
     - 用户关注、推荐模型
 - List
   - 存储类型
     - 有序的字符串，元素可以重复，最大存储量2^32-1（约40亿）
   - 操作命令
   - 存储结构
     - quicklist[数组+链表]
   - 应用场景
    - 各种列表
    - 队列/栈
 - Zset
   - 存储类型
     - 有序不重复的元素，每个元素有个score，按照score从小到大排列(score相同时按照key的ASCII码排序)
   - 操作命令
   - 存储结构
     - ziplist
     - skiplist+dict
       - skiplist查找时需要比较的节点大约只有原来的一半，实现比AVL树或红黑树更简洁
   - 应用场景
     - 顺序会动态变化的场景，例如排行榜、热搜
 - Hyperloglog
 - Geo
 - Streams

# 原理
- 发布订阅
  - 支持一次订阅多个
  - 按规则Pattern订阅频道
  - Sentinel模式用到了此功能
- 事务
  - 特点
    - 按进入队列的顺序执行
    - 不会受到其它客户端请求的应用
    - 事务不能嵌套，多个multi命令效果一样
  - 命令
    - multi 开启事务
    - exec 执行事务
    - discard 取消事务
    - watch 监视 可以监视一个或多个key，如果开启事务之后，至少有一个被监视的key在exec执行前被修改了，那么整个事务都会被取消(key提前过期除外)
- Lua脚本
  - 轻量级脚本语言，C语言编写
  - 使用lua脚本执行redis命令好处
    - 一次发送多个命令，减少网络开销
    - Redis会将整个脚本作为整体执行，不会被其它请求打断，保证原子性
    - 对于复杂的命令组合，可以放在文件中，实现命令复用
  - 缓存脚本
  - 脚本超时
- 单线程工作机制
  - Redis为什么这么快
    - 纯内存结构
    - 请求处理单线程
    - 多路复用机制
- 内存回收
  - 过期策略
    - 立即过期 每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除
    - 惰性过期 只有当访问一个key时，才会判断该key是否已过期，过期则清除
    - 定期过期 每隔一定时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key
  - 淘汰策略
    - **volatile-lru**[推荐]
    - allkeys-lru
    - volatile-lfu
    - allkeys-lfu
    - volatile-random
    - allkeys-random
    - volatile-ttl
- 持久化
  - RDB，Redis Database
    - 默认方案，但如果开启AOF则优先使用AOF
    - 当满足一定条件时，会将当前内存中的数据写入磁盘，生成一个快照文件dump.rdb；Redis重启会通过加载该文件来恢复数据
  - AOF，Append Only File    
    - 默认不开启
    - 采用日志的形式来记录每个写操作并追加到文件中
  - 两种方案比较
    - 如果可以忍受一小段时间内数据的丢失，可以使用RDB定时生成快照，并且恢复速度比AOF快。否则，就使用AOF
    - 一般情况下，两种方式组合使用

# 分布式
- 为什么需要支持分布式
  - 性能
  - 高可用
  - 可扩展
- 关键技术
  - 分片
  - 冗余
- 主从复制
  - 配置方式
    - redis.config
      - replicaof <master-ip> <master-port>
    - 启动服务时指定参数
      - ./redis-server --slaveof <master-ip> <master-port>
    - 在客户端直接执行命令
      - slaveof <master-ip> <master-port>
  - 实现原理
    - 全量同步
    - 增量同步
- 可用性保证之sentinel
  - Raft算法实现Leader选举 http://thesecretlivesofdata.com/raft/
  
- 分布式方案
  - 客户端实现 取模或者一致性哈希(哈希环)对key进行分片，查询或修改都先判断key的路由
    - SharedJedis
  - 代理服务 抽取分片处理逻辑，运行一个独立的代理服务，客户端连接到代理服务，代理服务做请求转发
    - Twemproxy
    - Codis
  - 服务端实现 
    - Redis Cluster


# 实战
- Redis客户端
  - 通信协议 RESP Redis Serialization Protocol
  - 常用客户端
    - Jedis 小巧但功能完善
    - Luttuce 高级客户端，支持线程安全、异步、反应式编程、集群、哨兵、pipline、编解码
    - Redisson 基于Redis服务实现的Java分布式可扩展的数据结构
- 数据一致性 
  - 先操作redis再操作数据库
  - 先操作数据库再操作redis
  - 实时一致性 牺牲性能
  - 最终一致性 牺牲准确性
- 高并发问题
  - 热点数据发现
    - 基于缓存淘汰策略留存热点key
    - 客户端层 目前不考虑
    - 代理层 目前不考虑
    - 服务器层 使用monitor监控获取所有命令 redis-faina
      - 高并发场景下会影响性能
      - 只能统计一个Redis节点的热点Key
    - 机器层 使用elk的packetbeat插件进行抓包分析
  - 缓存雪崩——大量热点数据同时过期
    - 加锁 使用互斥锁或队列，针对同一个key只允许一个线程到数据库查询
    - 预更新 缓存定时预更新，避免同时失效
    - ttl加随机数
    - 永不过期 如果确认为常用热点数据，设置为永不过期
  - 缓存击穿——热点key过期
    - 确认为热点数据且物理内存能抗住，则设置永不过期
  - 缓存穿透——直接请求数据库中不存在的值，redis直接失效
    - 哈希运算+位运算+BitSet，通过 扩大位图 或 多次哈希 降低哈希碰撞概率
      - 使用布隆过滤器(Guava)
        - 容器角度 布隆过滤器判断元素在集合中存在，实际不一定存在；判断不存在，则一定不存在
        - 元素角度 元素实际存在，则布隆过滤器一定判断存在；元素实际不存在，布隆过滤器可能判断存在
    - 布隆过滤器也可以解决从海量数据中快速判断某个元素是否存在 

# 规范
以下规范为强制要求，code review时若发现不符合规范需要重新修改
- 命名统一使用小写字母，以冒号分隔   
  例：token:refresh:lock
- 避免不必要的Exists操作   
  Redis与MySQL等关系型数据库不同，很多操作自带了判断数据是否存在的功能，例如setnx、del等指令。因而许多情况下无需先Exists查询数据是否存在后再执行操作，直接执行操作即可，可节省一半的网络请求
- 释放分布式锁前，判断是否是自己加的锁，避免误释放
- 需要单机执行的定时任务，抢锁后不要释放锁  
  避免定时任务执行太快，锁释放的速度比多台机器的接收到redis publish消息的时间差还快，导致多台机器同时执行定时任务
- 获取Jedis后必须主动归还资源  
  JedisTemplate中大部分的Redis操作自带了归还功能，此时无需手动归还资源；当使用JedisTemplate中未包含的方法(如TTL等)时，需要手动获取Jedis以执行这些方法，此时务必记得归还资源，否则资源无法回收会出现连接池打满的异常
- 分布式锁的超时时间不得小于该方法可能的最长执行时间  
  例：执行方法中包含http调用，则该锁的超时时间必须大于http调用设置的超时时间
- 分布式锁的执行方法如果包含循环，无法判定最长执行时间，则需要进行锁续期
- 谨慎使用时间复杂度为O(n)的命令  
  keys、hgetall、lrange、smembers、zrange等命令，使用时必须关注n的大小，避免数量过多的值打爆内存
- 注意value的大小，禁止保存过大的内容  
  benchmark的结果是value值的大小超过10KB，就会对性能有较大损害
- Redis中不要保存永久数据，必须设定过期时间  
  Redis只用来存储缓存、Token这些临时数据，这些数据必须设置过期时间，第一，可以避免随着时间推移，内存中存储大量失效的数据；第二，一旦缓存和数据库中的数据由于程序bug发生不一致的情况，设置过期时间至少可以保证key过期之后可以达到最终一致性  
