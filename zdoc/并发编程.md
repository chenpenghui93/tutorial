# 并发编程的发展及价值
## 多线程实现原理
## 线程运行状态
## 线程终止
### 一个线程在什么情况是执行结束了
通过start()方法启动一个线程后，本质上就是在执行这个线程的run()方法；在这个线程的run()方法执行完之前，一直处于运行状态，
直到run()中的指令执行完毕，那么这个线程就会被销毁。正常情况下，这个线程是不需要人为干预去结束的，如果要强制结束，只能走stop()
当线程中存在以下情况时，线程的中断需要外部干预
- 线程中存在无限循环执行，例如while(true)
- 线程中存在阻塞操作，例如sleep、wait、join等

### 中断存在死循环的线程
- thread.interrupt()
- thread.currentThread().isInterrupted()

### 中断阻塞状态下的线程
- 阻塞期间抛出InterruptedException异常，以响应被其他线程发起的中断请求；但在异常中如果不做任何处理的话，是无法中断线程的，
因为当前的异常只是响应了外部对于这个线程的中断命令，同时线程的中断状态也会复位，
如果需要中断，则需要在catch块中添加Thread.currentThread().interrupt();
- InterruptedException异常的抛出并不意味着线程的终止，而是提醒当前线程有中断的操作发生，至于接下来怎么处理取决于线程本身，比如
 - 直接捕获异常不做任何处理
 - 将异常向外抛出
 - 停止当前线程，并打印异常信息

### Thread dump日志分析
- CPU占用率不高，但响应很慢/线程出现死锁的情况
  - 通过jps查看java进程的pid
  - 通过jstack查看线程日志
- CPU占用率很高，但响应很慢
  - 执行`top -c`动态显示进程及占用资源的排行榜，从而找到占用CPU最高的进程PID
  - 执行`top -H -p 80972`定位到80972进程中最消耗CPU的线程
  - 执行`printf "0x%x\n" 81122`命令，把对应的线程PID转化为16进制
  - 执行`jstack 80972 | grep -A 20 0x13ce2`查看进程id为80972中线程id为0x13ce2的前20行Dump日志


# 并发编程带来的挑战之同步锁

# 并发编程带来的挑战之可见性

# 并发安全性之Lock锁及原理分析

