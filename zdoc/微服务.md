# 架构演进
- 单体架构
  - 项目初期面临的访问量少，单一应用即可实现所需功能
  - 开发、部署、维护的难度较小
- 垂直应用架构
  - 用户访问量增加，单一应用需要不断增加服务器来应对
  - 将单一应用拆分成多个应用来提升处理效率
  - 应用分层
    - UI层
    - 业务逻辑层
    - 数据库层
- 服务化架构(SOA)
  - 访问量持续提升，系统负重增多，无法满足并发访问需求
  - 将应用根据不同职责划分成不同的模块，使用服务化架构
- 微服务架构
  - SOA架构的一种拓展，关注服务个体的独立性、拆分粒度更小
  - 强调组件化和服务化，每个微服务可以拥有独立的运行空间
  - 抛弃企业服务总线，强调使用HTTP Rest API的接口发布形式
  - 切分力度较大
- Spring Cloud解决了什么问题/分布式微服务有哪些问题

# 技术选型
- 服务注册与发现
  - eureka
    - 保证AP，Eureka各个节点都是平等的，当其中某几个节点挂掉时，剩余节点依然可以提供注册和查询服务；当客户端向某个Eureka注册或发现连接失败时，
      则会自动切换到其它节点，只要有一台Eureka还在，就能保证注册服务可用（保证可用性），只不过查到的信息可能不是最新的（不保证强一致性）
  - nacos
  - zookeeper
    - 保证CP，当master节点因为网络故障与其它节点失去联系时，剩余节点会进行leader选举；选举期间(30~120s)整个zk集群是不可用的
- 服务网关(鉴权、路由、流控)
  - gateway
- 配置管理(集中管理、热部署)
  - xxx
- 服务间调用
  - feign
- 服务熔断、降级
  - hystrix
- 容错限流
  - sentinel
- 负载均衡
  - ribbon
- 链路追踪

# 实践问题--幂等问题
- 什么是幂等 https://juejin.cn/post/6906290538761158670
  - 用户对同一个操作发起多次请求以后，对数据的影响结果是不变的，一次请求和n次请求的结果都是一样的
- 常见场景：
  - 网络波动
  - 分布式消息消费
  - 用户重复操作
  - 未关闭的重试机制
- 常见问题
  - 电商超卖现象
    - 直接对读操作加显示锁
    - 有条件有选择的在读操作上加锁
  - 重复转账、扣款或付款
  - 重复增加积分、优惠券
- 解决方案
  - 全局唯一ID：根据业务的操作和内容生成一个分布式全局id，在执行操作前先根据全局唯一id是否存在，来判断当前操作是否已经执行
              如果不存在，则执行操作并存储全局唯一id；如果存在则表示该方法已经执行；考虑使用snowflake算法、数据库号段模式、Redis存储防重token令牌
  - 数据库的唯一性约束：对某一个关键数据设置一个唯一索引，重复请求过来之后无法正常入库，抛出一个重复异常，服务端可以捕获这个异常
  - 乐观锁多版本控制：增加版本号字段进行标识，只适用于更新操作；`where id=1 and version=5`第一次更新成功后version+1变为6，重复请求过来后无法更新成功
  - 状态机幂等控制：状态机流转

