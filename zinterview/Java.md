### 基础 Basic
- 如何理解面向对象思想  
  - 一切皆对象，对象有属性和方法，通过操纵对象的方法改变对象的属性来实现想要的结果  
- `equals()`与 `==`的区别  
  - 默认情况下，从Object继承的`equals()`与`==`是完全等价的，二者比较的都是对象的内存地址
  - 可以重写业务对象的`equals()`，使其按照需要的方式进行比较，这种时候`equals()`一般比较的就是对象的内容，而不是对象的内存地址了  

### 集合类 Collection
- ArrayList 底层使用 定长数组 实现，允许空值和重复元素
- LinkedList 底层使用 双向链表 实现，允许空值和重复值
- Vector 数组 Synchronized保证线程安全
- CopyOnWriteArrayList 数组 线程安全的ArrayList Synchronized修饰方法 对读不加锁、对写加锁
- HashMap 底层使用 数组+链表+红黑树(jdk1.8+) 实现
- LinkedHashMap 


### 输入/输出 I/O

### 异常 Exception

### 类加载 ClassLoader

### 并发与多线程 Thread

### 虚拟机 JVM

#### 垃圾回收 GC  https://blog.csdn.net/justloveyou_/article/details/71216049
- Java中自动内存管理解决的问题
 - 给对象分配内存，回收分配给对象的内存；针对的内存区域是Java内存模型中的堆区
 - 哪些内存要回收
 - 什么时候回收
 - 如何回收
- 为什么要使用垃圾回收
  - 防止内存泄漏，保证内存的有效使用
- 如何确定对象是否可以被回收
  - 引用计数算法，任何引用计数为0的对象实例可以被当作垃圾收集——无法解决循环引用问题
  - 可达性分析算法，通过判断对象的引用链是否可达来决定对象是否可以被回收
    - 虚拟机栈(栈帧中的局部变量表)中引用的对象
    - 方法区中类静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈中native方法引用的对象
- 标记-清除算法
  - 首先从根集合进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收
  - 标记和清除两个过程效率都不高
  - 不需要进行对象的移动，仅对不存活的对象进行处理，因此也会产生大量不连续的内存碎片
- 复制算法
  - 将可用内存按容量划分为大小相等的两块，每次只使用其中一块；当这一块的内存用完了，就将还存活着的对象复制到另一块上，然后再把已使用过的内存空间一次性清理调
  - 适用于对象存活率低的场景，如 新生代
- 标记-整理算法
  - 标记-整理算法的标记过程类似标记-清除算法，但后续步骤不是直接对可回收对象直接进行清理，而是让所有存活的对象向一端移动，然后清理掉端边界以外的内存，类似于磁盘整理的过程
  - 适用于对象存活率高的场景，如 老年代
- 分代收集算法
  - 不同对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此堆内存对不同的区域采用不同的策略进行回收以提高JVM的执行效率
  - 堆内存区域划分
    - 新生代
      - 新生代的目标就是尽可能快速地收集掉那些生命周期短的对象，一般情况下，所有新生成的对象都是存放在新生代中
      - Eden→Survivor0;
      - Eden+Survivor0→Survivor1,交换Survivor0/Survivor1
      - 新生代→老年代
      - FullGC，回收新生代、老年代
    - 老年代
      - 老年代中存放的都是生命周期较长的对象；内存比例老年代大约为新生代的两倍
    - 永久代
      - 主要用于存放静态文件，如Java类、方法等。永久代对垃圾回收没有显著影响，但使用反射、动态代理、CGLib等方式时，
        需要设置一个比较大的永久代内存空间来存放这些运行过程中新增的类
- 垃圾回收有两种类型
  - Minor GC,对新生代进行回收，不会影响老年代
  - Full GC(Major GC),对整个堆进行回收，包括新生代和老年代。导致发生Full GC的原因包括：老年代被写满、永久代被写满、System.gc()被显示调用等
  
- 垃圾收集器
  - Serial 
  - Serial Old
  - ParNew
  - Parallel Scavenge 
  - Parallel Old
  - Concurrent Mark Sweep,CMS
  - Garbage First,G1
  
- 内存分配与回收策略
  - 一般而言，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓存(TLAB)，将按线程优先在TLAB上分配。少数情况下也可能直接分配在老年代中。
    总的来说，内存分配规则并不是一层不变的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置
  - 1.对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC
  - 2.大对象直接进入老年代
  - 3.长期存活的对象将进入老年代
  - 4.动态对象年龄判定
  
- 内存泄漏的可能情况
  - 例如HashMap、Vector等集合类的静态使用
  - 各种资源连接包括数据库连接、网络连接、IO连接等没有显式调用close关闭，不被GC回收导致内存泄漏
  - 监听器的使用，在释放对象的时候没有对应删除监听器
  
- 引用 `示例 https://www.jianshu.com/p/e5364c05cc80`
  - 强引用 "Object obj = new Object()" 只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象
  - 软引用 有用但非必须的对象。通过SoftwareReference实现软引用
  - 弱引用 非必需对象，强度比软引用更弱一些。通过WeakReference实现弱引用
  - 虚引用 最弱的引用关系。通过PhantomReference实现虚引用
  
